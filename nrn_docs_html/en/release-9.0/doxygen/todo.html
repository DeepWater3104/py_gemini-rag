<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NEURON: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<script async type="text/javascript" src="/_/static/javascript/readthedocs-addons.js"></script><meta name="readthedocs-project-slug" content="nrn" /><meta name="readthedocs-version-slug" content="release-9.0" /><meta name="readthedocs-resolver-filename" content="/doxygen/todo.html" /><meta name="readthedocs-http-status" content="200" /></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NEURON
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('todo.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt>Member <a class="el" href="namespacecoreneuron.html#af66ef352f77c5506a18125082c337607">coreneuron::nrn_cleanup_ion_map</a>  ()</dt>
<dd><a class="anchor" id="_todo000001"></a>coreneuron should have finalise callback which can be called from NEURON for final memory cleanup including global state like registered mechanisms and ions map.  </dd>
<dt>Member <a class="el" href="namespacecoreneuron.html#a0b4f6bb469a301bb08fab3b419ec9b2f">coreneuron::nrnran123_newstream3</a>  (uint32_t id1, uint32_t id2, uint32_t id3, bool use_unified_memory)</dt>
<dd><a class="anchor" id="_todo000005"></a>It would be nicer if the API return type was std::unique_ptr&lt;nrnran123_State, ...not specified...&gt;, so we could use a custom allocator/deleter and avoid the (fragile) need for matching nrnran123_deletestream calls.  </dd>
<dt>Member <a class="el" href="enginemech_8cpp.html#a76181556fd04cd67d6ce393c3d8ab371">corenrn_embedded_run</a>  (int nthread, int have_gaps, int use_mpi, int use_fast_imem, const char *mpi_lib, const char *nrn_arg, int file_mode)</dt>
<dd><a class="anchor" id="_todo000002"></a>Change return type semantics  </dd>
<dt>Member <a class="el" href="group__hoc__functions.html#ga5902b5a8c718689ae3ad748be842935f">hoc_get_arg</a>  (std::size_t narg)</dt>
<dd><a class="anchor" id="_todo000083"></a>Should the stack be modified such that this can return const references, even for things like data_handle&lt;T&gt; that at the moment are not exactly stored (we store generic_data_handle, which can produce a data_handle&lt;T&gt; on demand but which does not, at present, actually <em>contain</em> a data_handle&lt;T&gt;)?  </dd>
<dt>Member <a class="el" href="struct_memb__list.html#a1395258c8925b2f4082c9faa6fd25040">Memb_list::set_storage_offset</a>  (std::size_t offset)</dt>
<dd><a class="anchor" id="_todo000080"></a>At the moment this is set as part of sorting/permuting data, but it is not automatically invalidated when the cache / sorted status is reset. Consider if these offsets can be more explicitly tied to the lifetime of the cache data.  </dd>
<dt>File <a class="el" href="nmodl_2lexer_2modl_8h.html">modl.h</a>  </dt>
<dd><a class="anchor" id="_todo000043"></a>Add these bit masks as enum-flags and remove this legacy header  </dd>
<dt>Class <a class="el" href="structneuron_1_1container_1_1data__handle.html">neuron::container::data_handle&lt; T &gt;</a>  </dt>
<dd><a class="anchor" id="_todo000006"></a>Const correctness &ndash; <a class="el" href="structneuron_1_1container_1_1data__handle.html" title="Stable handle to a generic value.">data_handle</a> should be like span: <a class="el" href="structneuron_1_1container_1_1data__handle.html">data_handle&lt;double&gt;</a> can read + write the value, data_handle&lt;double const&gt; can only read the value. const applied to the <a class="el" href="structneuron_1_1container_1_1data__handle.html" title="Stable handle to a generic value.">data_handle</a> itself should just control whether or not it can be rebound to refer elsewhere.  </dd>
<dt>Member <a class="el" href="structneuron_1_1container_1_1detail_1_1field__data_3_01_tag_00_01_field_implementation_1_1_runtime_variable_01_4.html#a4513b1e773b46bb80215ee19197a108d">neuron::container::detail::field_data&lt; Tag, FieldImplementation::RuntimeVariable &gt;::m_array_dim_prefix_sums</a>  </dt>
<dd><a class="anchor" id="_todo000014"></a>This could be used to more efficiently convert legacy indices. </dd>
<dt>Class <a class="el" href="structneuron_1_1container_1_1generic__data__handle.html">neuron::container::generic_data_handle</a>  </dt>
<dd><a class="anchor" id="_todo000007"></a>Consider whether this should be made more like std::any (with a maximum 2*sizeof(void*) and a promise never to allocate memory dynamically) so it actually has a data_handle&lt;T&gt; subobject. Presumably that would mean data_handle&lt;T&gt; would need to have a trivial destructor. This might make it harder in future to have some vector_of_generic_data_handle type that hoists out the pointer-to-container and typeid parts that should be the same for all rows.  </dd>
<dt>Member <a class="el" href="structneuron_1_1container_1_1generic__data__handle.html#aa4e163e868cfcfc9d6340fb506d2bc0a">neuron::container::generic_data_handle::get</a>  () const</dt>
<dd><a class="anchor" id="_todo000008"></a>Consider conversion to bool and whether this means not-null or to obtain a literal, wrapped bool value  </dd>
<dt>Member <a class="el" href="structneuron_1_1container_1_1handle__base.html#a0e3d8f0a4c8c67fd833559554fcfbf54">neuron::container::handle_base&lt; Identifier &gt;::get_handle</a>  ()</dt>
<dd><a class="anchor" id="_todo000019"></a>const cleanup &ndash; should there be a const version returning data_handle&lt;T const&gt;?  </dd>
<dt>Member <a class="el" href="structneuron_1_1container_1_1handle__base.html#abf028fa767852fd03fbe4bf4e2f457f5">neuron::container::handle_base&lt; Identifier &gt;::get_handle</a>  (int <a class="el" href="structneuron_1_1container_1_1field__index.html" title="Struct used to index SoAoS data, such as array range variables.">field_index</a>, int array_offset=0)</dt>
<dd><a class="anchor" id="_todo000020"></a>Const cleanup as above for the zero-argument version.  </dd>
<dt>Member <a class="el" href="structneuron_1_1container_1_1handle__base.html#a4cb869492c8fb1afa64ed63ea980d6c2">neuron::container::handle_base&lt; Identifier &gt;::id_hack</a>  () const</dt>
<dd><a class="anchor" id="_todo000018"></a>Remove those macros once and for all.  </dd>
<dt>Class <a class="el" href="structneuron_1_1container_1_1_mechanism_1_1field_1_1_floating_point.html">neuron::container::Mechanism::field::FloatingPoint</a>  </dt>
<dd><a class="anchor" id="_todo000009"></a>Update the code generation so we get some hh_data = soa&lt;hh_identifier, hh_a, hh_b, ...&gt; type instead of fudging things this way.  </dd>
<dt>Member <a class="el" href="structneuron_1_1container_1_1_node_1_1handle__interface.html#a6b89741e5a5c5abcab92d26e23e39b3a">neuron::container::Node::handle_interface&lt; Identifier &gt;::area_hack</a>  ()</dt>
<dd><a class="anchor" id="_todo000010"></a>Remove those macros once and for all.  </dd>
<dt>Member <a class="el" href="structneuron_1_1container_1_1_node_1_1handle__interface.html#aaa514eca11d948e2eb662da9f4b4fde0">neuron::container::Node::handle_interface&lt; Identifier &gt;::area_hack</a>  () const</dt>
<dd><a class="anchor" id="_todo000011"></a>Remove those macros once and for all.  </dd>
<dt>Member <a class="el" href="structneuron_1_1container_1_1_node_1_1handle__interface.html#a4737825fa761a935f35be93c877708f0">neuron::container::Node::handle_interface&lt; Identifier &gt;::v_hack</a>  ()</dt>
<dd><a class="anchor" id="_todo000012"></a>Remove those macros once and for all.  </dd>
<dt>Member <a class="el" href="structneuron_1_1container_1_1_node_1_1handle__interface.html#a06039cc461fed270c9cf676d966ce3cb">neuron::container::Node::handle_interface&lt; Identifier &gt;::v_hack</a>  () const</dt>
<dd><a class="anchor" id="_todo000013"></a>Remove those macros once and for all.  </dd>
<dt>Member <a class="el" href="structneuron_1_1container_1_1soa.html#a5c391ab9bb358f5ca8a72512fcdbcf64">neuron::container::soa&lt; Storage, Tags &gt;::find_data_handle</a>  (<a class="el" href="structneuron_1_1container_1_1generic__data__handle.html" title="Non-template stable handle to a generic value.">neuron::container::generic_data_handle</a> input_handle) const</dt>
<dd><a class="anchor" id="_todo000016"></a>Check const-correctness. Presumably a const version would return data_handle&lt;T const&gt;, which would hold a pointer-to-const for the container? </dd>
<dt>Member <a class="el" href="structneuron_1_1container_1_1soa.html#ad9d6731fd32b1a4ab2a238c269802de0">neuron::container::soa&lt; Storage, Tags &gt;::is_storage_pointer</a>  (typename Tag::type const *ptr) const</dt>
<dd><a class="anchor" id="_todo000017"></a>Fix this for tag types with num_variables()? </dd>
<dt>Member <a class="el" href="structneuron_1_1container_1_1soa.html#a54b3da5eeb40d7038f4eac42fc53dd05">neuron::container::soa&lt; Storage, Tags &gt;::issue_frozen_token</a>  ()</dt>
<dd><a class="anchor" id="_todo000015"></a>A future extension could be to preserve the sorted flag until pointers are actually, not potentially, invalidated.  </dd>
<dt>Class <a class="el" href="structnmodl_1_1ast_1_1_ast.html">nmodl::ast::Ast</a>  </dt>
<dd><a class="anchor" id="_todo000086"></a>With the <a class="el" href="classnmodl_1_1ast_1_1_node.html" title="Base class for all AST node.">ast::Node</a> as another top level node, this can be removed in the future.  </dd>
<dt>Class <a class="el" href="classnmodl_1_1ast_1_1_constant_statement.html">nmodl::ast::ConstantStatement</a>  </dt>
<dd><a class="anchor" id="_todo000087"></a>As <a class="el" href="classnmodl_1_1ast_1_1_constant_statement.html" title="Represent statement in CONSTANT block of NMODL.">ConstantStatement</a> wraps a single <a class="el" href="classnmodl_1_1ast_1_1_constant_var.html" title="Represents a variable in the ast::ConstantBlock.">ConstantVar</a>, this or <a class="el" href="classnmodl_1_1ast_1_1_constant_var.html" title="Represents a variable in the ast::ConstantBlock.">ast::ConstantVar</a> can be redundant in the future. </dd>
<dt>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_acc_visitor.html#a0afbe91263bad633cba874fd9c7b5af6">nmodl::codegen::CodegenAccVisitor::print_abort_routine</a>  () const override</dt>
<dd><a class="anchor" id="_todo000021"></a>: we need to implement proper error handling mechanism to propogate errors from GPU to CPU. For example, error code can be returned like original neuron implementation. For now we use <code>assert(0==1)</code> pattern which is used for OpenACC.  </dd>
<dt>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_acc_visitor.html#a532e903a7bb7f8c3dfeac467f53e111d">nmodl::codegen::CodegenAccVisitor::print_net_init_acc_serial_annotation_block_begin</a>  () override</dt>
<dd><a class="anchor" id="_todo000022"></a>: With the current code structure for NMODL and MOD2C, we use <code>serial</code> construct to launch serial kernels. This is during initialization but still inefficient. This should be improved when we drop MOD2C.  </dd>
<dt>Class <a class="el" href="classnmodl_1_1codegen_1_1_codegen_coreneuron_cpp_visitor.html">nmodl::codegen::CodegenCoreneuronCppVisitor</a>  </dt>
<dd><a class="anchor" id="_todo000031"></a><ul>
<li>Handle define statement (i.e. macros)</li>
<li>If there is a return statement in the verbatim block of inlined function then it will be error. Need better error checking. For example, see netstim.mod where we have removed return from verbatim block.  </li>
</ul>
</dd>
<dt>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_coreneuron_cpp_visitor.html#a009be25d4dc1397524ed5364898d5997">nmodl::codegen::CodegenCoreneuronCppVisitor::append_conc_write_statements</a>  (std::vector&lt; ShadowUseStatement &gt; &amp;statements, const <a class="el" href="structnmodl_1_1codegen_1_1_ion.html" title="Represent ions used in mod file.">Ion</a> &amp;ion, const std::string &amp;concentration) override</dt>
<dd><a class="anchor" id="_todo000025"></a>Unhandled case in neuron implementation  </dd>
<dt>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_coreneuron_cpp_visitor.html#af48766525e3a1c8f88471a9338ae59e7">nmodl::codegen::CodegenCoreneuronCppVisitor::internal_method_parameters</a>  () override</dt>
<dd><a class="anchor" id="_todo000023"></a>: figure out how to correctly handle qualifiers  </dd>
<dt>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_coreneuron_cpp_visitor.html#a93aa5868249076c8b0766369cbbba993">nmodl::codegen::CodegenCoreneuronCppVisitor::print_derivimplicit_kernel</a>  (const <a class="el" href="classnmodl_1_1ast_1_1_block.html" title="Base class for all block scoped nodes.">ast::Block</a> &amp;block)</dt>
<dd><a class="anchor" id="_todo000029"></a><a class="el" href="struct_data.html">Data</a> is not derived. </dd>
<dt>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_coreneuron_cpp_visitor.html#a38c76390b1d1c0a5cf1fe8df3f27fb57">nmodl::codegen::CodegenCoreneuronCppVisitor::print_nrn_state</a>  () override</dt>
<dd><a class="anchor" id="_todo000030"></a>Eigen solver node also emits IonCurVar variable in the functor but that shouldn't update ions in derivative block  </dd>
<dt>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_coreneuron_cpp_visitor.html#a8366981bc5ecb9b4d52af74865e16bb6">nmodl::codegen::CodegenCoreneuronCppVisitor::print_watch_activate</a>  ()</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000027"></a>Similar to neuron/coreneuron we are using first watch and ignoring rest. </p>
<p class="enddd"><a class="anchor" id="_todo000026"></a>Number of watch could be more than number of statements according to grammar. </p>
</dd>
<dt>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_coreneuron_cpp_visitor.html#a3ea1bf8ef47090b926d8738d18306de7">nmodl::codegen::CodegenCoreneuronCppVisitor::print_watch_check</a>  ()</dt>
<dd><a class="anchor" id="_todo000028"></a>Similar to print_watch_activate, we are using only first watch. </dd>
<dt>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_coreneuron_cpp_visitor.html#acc2329629c7a66940c56e894cae941b3">nmodl::codegen::CodegenCoreneuronCppVisitor::process_verbatim_text</a>  (std::string const &amp;text)</dt>
<dd><a class="anchor" id="_todo000024"></a>: this is still ad-hoc and requires re-implementation to handle it more elegantly.  </dd>
<dt>Class <a class="el" href="classnmodl_1_1codegen_1_1_codegen_cpp_visitor.html">nmodl::codegen::CodegenCppVisitor</a>  </dt>
<dd><a class="anchor" id="_todo000034"></a><ul>
<li>Handle define statement (i.e. macros)</li>
<li>If there is a return statement in the verbatim block of inlined function then it will be error. Need better error checking. For example, see netstim.mod where we have removed return from verbatim block.  </li>
</ul>
</dd>
<dt>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_cpp_visitor.html#a2a1e5337a20e3f1dad1d1dfbb89fbb1b">nmodl::codegen::CodegenCppVisitor::codegen_global_variables</a>  </dt>
<dd><a class="anchor" id="_todo000035"></a>: this has become different than <a class="el" href="structnmodl_1_1codegen_1_1_codegen_info.html" title="Represent information collected from AST for code generation.">CodegenInfo</a>  </dd>
<dt>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_cpp_visitor.html#a4f2304d508e3d9645581004c676d94ca">nmodl::codegen::CodegenCppVisitor::visit_var_name</a>  (const <a class="el" href="classnmodl_1_1ast_1_1_var_name.html" title="Represents a variable.">ast::VarName</a> &amp;node) override</dt>
<dd><a class="anchor" id="_todo000032"></a>: Validate how @ is being handled in neuron implementation  </dd>
<dt>Class <a class="el" href="classnmodl_1_1codegen_1_1_codegen_helper_visitor.html">nmodl::codegen::CodegenHelperVisitor</a>  </dt>
<dd><a class="anchor" id="_todo000038"></a><ul>
<li>Determine <code>vectorize</code> as part of the pass</li>
<li>Determine <code>threadsafe</code> as part of the pass</li>
<li>Global variable order is not preserved, for example, below gives different order:<ul>
<li>NEURON block: GLOBAL gq, gp</li>
<li>PARAMETER block: gp = 11, gq[2]</li>
</ul>
</li>
<li>POINTER rng and if it's also assigned rng[4] then it is printed as one value. Need to check what is correct value.  </li>
</ul>
</dd>
<dt>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_helper_visitor.html#adaa15452418bc8a98d8a205e8fcfb110">nmodl::codegen::CodegenHelperVisitor::find_non_range_variables</a>  ()</dt>
<dd><a class="anchor" id="_todo000036"></a>Below we calculate thread related id and sizes. This will need to do from global analysis pass as here we are handling top local variables, global variables, derivimplicit method. There might be more use cases with other solver methods.  </dd>
<dt>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_helper_visitor.html#ab0efef492595d0e818b6ad5ab50ea595">nmodl::codegen::CodegenHelperVisitor::visit_statement_block</a>  (const <a class="el" href="classnmodl_1_1ast_1_1_statement_block.html" title="Represents block encapsulating list of statements.">ast::StatementBlock</a> &amp;node) override</dt>
<dd><a class="anchor" id="_todo000037"></a>AST can have duplicate DERIVATIVE blocks if a mod file uses SOLVE statements in its INITIAL block (e.g. in case of kinetic schemes using <code>STEADYSTATE sparse</code> solver). Such duplicated DERIVATIVE blocks could be removed by <code>SolveBlockVisitor</code>, or we have to avoid visiting them here. See e.g. SH_na8st.mod test and original reduced_dentate .mod.  </dd>
<dt>Class <a class="el" href="structnmodl_1_1codegen_1_1_codegen_info.html">nmodl::codegen::CodegenInfo</a>  </dt>
<dd><a class="anchor" id="_todo000039"></a>Need to store all Define i.e. macro definitions?  </dd>
<dt>Class <a class="el" href="classnmodl_1_1codegen_1_1_codegen_neuron_cpp_visitor.html">nmodl::codegen::CodegenNeuronCppVisitor</a>  </dt>
<dd><a class="anchor" id="_todo000042"></a><ul>
<li>Handle define statement (i.e. macros)</li>
<li>If there is a return statement in the verbatim block of inlined function then it will be error. Need better error checking. For example, see netstim.mod where we have removed return from verbatim block.  </li>
</ul>
</dd>
<dt>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_neuron_cpp_visitor.html#a24c55a8420d179cbbd7bc6968f3c12e3">nmodl::codegen::CodegenNeuronCppVisitor::print_nrn_state</a>  () override</dt>
<dd><a class="anchor" id="_todo000041"></a>Eigen solver node also emits IonCurVar variable in the functor but that shouldn't update ions in derivative block  </dd>
<dt>Member <a class="el" href="namespacenmodl_1_1codegen_1_1naming.html#a86a9d3a0e50e4b2647e45c1ea5fd2e07">nmodl::codegen::naming::NMODL_VERSION</a>  []</dt>
<dd><a class="anchor" id="_todo000040"></a>: should be moved from codegen to global scope  </dd>
<dt>Class <a class="el" href="structnmodl_1_1codegen_1_1_shadow_use_statement.html">nmodl::codegen::ShadowUseStatement</a>  </dt>
<dd><a class="anchor" id="_todo000033"></a>If shadow_lhs is empty then we assume shadow statement not required  </dd>
<dt>Member <a class="el" href="namespacenmodl_1_1details.html#af8848d52bfe6c5128bb476ac5c604563">nmodl::details::keywords</a>  </dt>
<dd><a class="anchor" id="_todo000046"></a>Some keywords have different token names, e.g. TITLE keyword has MODEL as a keyword. These token names are used in multiple context and hence we are keeping original names. Once we finish code generation part then we change this.  </dd>
<dt>Member <a class="el" href="namespacenmodl_1_1details.html#a7f29649995b2bc1d04ba4314e71afcb4">nmodl::details::methods</a>  </dt>
<dd><a class="anchor" id="_todo000047"></a><a class="el" href="structnmodl_1_1details_1_1_method_info.html#aeab10f5665538150a35f61b30b71e64b" title="block types where this method will work with">MethodInfo::subtype</a> should be changed from integer flag to proper type  </dd>
<dt>Class <a class="el" href="classnmodl_1_1_mod_token.html">nmodl::ModToken</a>  </dt>
<dd><a class="anchor" id="_todo000044"></a><ul>
<li><a class="el" href="classnmodl_1_1_mod_token.html#a5edc9d18c2001be5017e2e2afc484ae1">LocationType</a> object is copyable except if we specify the stream name. It would be good to track filename when we go for multi-channel optimization and code generation. </li>
</ul>
</dd>
<dt>Member <a class="el" href="namespacenmodl.html#aa7c0916e51ccaf5779b7db1d1cd9fd8d">nmodl::name_symbol</a>  (const std::string &amp;text, PositionType &amp;pos, TokenType type)</dt>
<dd><a class="anchor" id="_todo000045"></a> In addition to keywords and methods, there are also external definitions for math and neuron specific functions/variables. In the token we should mark those as external.  </dd>
<dt>Namespace <a class="el" href="namespacenmodl_1_1parser_1_1diffeq.html">nmodl::parser::diffeq</a>  </dt>
<dd><a class="anchor" id="_todo000052"></a>The implementations here are verbose and has duplicate code. Need to revisit this, may be using better library like symengine altogether.  </dd>
<dt>Member <a class="el" href="classnmodl_1_1parser_1_1diffeq_1_1_diff_eq_context.html#ae54e71ef0da95411bf97f69e456da2d7">nmodl::parser::diffeq::DiffEqContext::cvode_deriv</a>  () const</dt>
<dd><a class="anchor" id="_todo000050"></a>Methods inherited neuron implementation  </dd>
<dt>Member <a class="el" href="classnmodl_1_1parser_1_1diffeq_1_1_diff_eq_context.html#a8c0e2e1e95d94888911b16a94c5c1421">nmodl::parser::diffeq::DiffEqContext::get_solution</a>  (bool &amp;cnexp_possible)</dt>
<dd><a class="anchor" id="_todo000048"></a>Currently we have tested cnexp, euler and derivimplicit methods with all equations from BBP models. Need to test this against various other mod files, especially kinetic schemes, reaction-diffusion etc.  </dd>
<dt>Member <a class="el" href="structnmodl_1_1parser_1_1diffeq_1_1_term.html#a405c13be238d68f836a1f118f6407991">nmodl::parser::diffeq::Term::a</a>  </dt>
<dd><a class="anchor" id="_todo000049"></a>Need to check in neuron implementation?  </dd>
<dt>Member <a class="el" href="classnmodl_1_1parser_1_1_diffeq_driver.html#ab89e4d42c0781358310684a3d5fc59ae">nmodl::parser::DiffeqDriver::cnexp_possible</a>  (const std::string &amp;equation, std::string &amp;solution)</dt>
<dd><a class="anchor" id="_todo000051"></a>Instead of using neuron like api, we need to refactor  </dd>
<dt>Class <a class="el" href="classnmodl_1_1parser_1_1_nmodl_driver.html">nmodl::parser::NmodlDriver</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000053"></a>Lexer, parser and ast member variables are used inside lexer/ parser instances. The local instaces are created inside parse_stream and hence the pointers are no longer valid except ast. Need better way to handle this.</p>
<p class="enddd"><a class="anchor" id="_todo000054"></a>Stream name is not used as it will need better support as location object used in scanner takes string pointer which could be invalid when we copy location object.  </p>
</dd>
<dt>Class <a class="el" href="classnmodl_1_1printer_1_1_j_s_o_n_printer.html">nmodl::printer::JSONPrinter</a>  </dt>
<dd><a class="anchor" id="_todo000055"></a>We need to explicitly call <code><a class="el" href="classnmodl_1_1printer_1_1_j_s_o_n_printer.html#a0fafa2042d3c4868e7571614702b9d00" title="Dump json object to stream (typically at the end) nspaces is number of spaces used for indentation.">flush()</a></code> in order to get write/return results. We simply can't dump block in <code>popBlock()</code> because block itself will be part of other parent elements. Also we are writing results to file, <code>stringstream</code> and <code>cout</code>. And hence we can't simply reset/clear previously written text.  </dd>
<dt>Class <a class="el" href="classnmodl_1_1printer_1_1_n_m_o_d_l_printer.html">nmodl::printer::NMODLPrinter</a>  </dt>
<dd><a class="anchor" id="_todo000056"></a>Implement Printer as base class to avoid duplication code between <a class="el" href="classnmodl_1_1printer_1_1_j_s_o_n_printer.html" title="Helper class for printing AST in JSON form.">JSONPrinter</a> and <a class="el" href="classnmodl_1_1printer_1_1_n_m_o_d_l_printer.html" title="Helper class for printing AST back to NMDOL test.">NMODLPrinter</a>.  </dd>
<dt>Class <a class="el" href="classnmodl_1_1symtab_1_1_model_symbol_table.html">nmodl::symtab::ModelSymbolTable</a>  </dt>
<dd><a class="anchor" id="_todo000063"></a>Unique name should be based on location. Use <a class="el" href="classnmodl_1_1_mod_token.html" title="Represent token returned by scanner.">ModToken</a> to get position.  </dd>
<dt>Member <a class="el" href="classnmodl_1_1symtab_1_1_model_symbol_table.html#a830dc2c0db6cba986b58d977996d0b3e">nmodl::symtab::ModelSymbolTable::get_unique_name</a>  (const std::string &amp;name, <a class="el" href="structnmodl_1_1ast_1_1_ast.html" title="Base class for all Abstract Syntax Tree node types.">ast::Ast</a> *node, bool is_global)</dt>
<dd><a class="anchor" id="_todo000061"></a>We should add position information to make name unique  </dd>
<dt>Class <a class="el" href="classnmodl_1_1symtab_1_1_symbol.html">nmodl::symtab::Symbol</a>  </dt>
<dd><a class="anchor" id="_todo000057"></a><ul>
<li>Multiple tokens (i.e. location information) for symbol should be tracked</li>
<li>Scope information should be more than just string</li>
<li>Perf block should track information about all usage of the symbol (would be helpful for perf modeling)</li>
<li>Need to keep track of all renaming information, currently only we keep last state  </li>
</ul>
</dd>
<dt>Member <a class="el" href="classnmodl_1_1symtab_1_1_symbol.html#aea4355d4eb499282cfcad1b29372efd3">nmodl::symtab::Symbol::is_external_variable</a>  () const noexcept</dt>
<dd><a class="anchor" id="_todo000058"></a>Need to check if we should check two properties using has_any_property instead of exact comparison </dd>
<dt>Class <a class="el" href="classnmodl_1_1symtab_1_1_symbol_table.html">nmodl::symtab::SymbolTable</a>  </dt>
<dd><a class="anchor" id="_todo000062"></a><ul>
<li>Revisit when clone method is used and implementation of copy constructor</li>
<li>Name may not require as we have added AST node  </li>
</ul>
</dd>
<dt>Member <a class="el" href="classnmodl_1_1symtab_1_1_symbol_table.html#ae1ec2b128700c6eb7321f5a1a641d78f">nmodl::symtab::SymbolTable::clone</a>  () const</dt>
<dd><a class="anchor" id="_todo000065"></a>Revisit the usage as tokens will be pointing to old nodes  </dd>
<dt>Class <a class="el" href="classnmodl_1_1symtab_1_1_symbol_table_1_1_table.html">nmodl::symtab::SymbolTable::Table</a>  </dt>
<dd><a class="anchor" id="_todo000064"></a>Re-implement pretty printing  </dd>
<dt>Member <a class="el" href="namespacenmodl_1_1symtab_1_1syminfo.html#ae05efbc3da8258a5240bcb2d605efaef">nmodl::symtab::syminfo::enum_type</a>  </dt>
<dd><a class="anchor" id="_todo000059"></a>Error with pybind if std::underlying_typ is used  </dd>
<dt>Member <a class="el" href="namespacenmodl_1_1symtab_1_1syminfo.html#ad9b6b8559b36d0a500ef5110badcc4db">nmodl::symtab::syminfo::NmodlType</a>  </dt>
<dd><a class="anchor" id="_todo000060"></a><ul>
<li>Rename param_assign to parameter_var  </li>
</ul>
</dd>
<dt>Member <a class="el" href="structnmodl_1_1test__utils_1_1_nmodl_test_case.html#a50cbab8eb69dbd5808d7da31e983dfde">nmodl::test_utils::NmodlTestCase::NmodlTestCase</a>  ()=delete</dt>
<dd><a class="anchor" id="_todo000085"></a>: add associated json (to use in visitor test)  </dd>
<dt>Member <a class="el" href="namespacenmodl_1_1visitor.html#a93218c244f2658370e096935410f2c42">nmodl::visitor::create_statement</a>  (const std::string &amp;code_statement)</dt>
<dd><a class="anchor" id="_todo000079"></a>Need to revisit this during code generation passes to make sure if all statements can be part of procedure block.  </dd>
<dt>Member <a class="el" href="classnmodl_1_1visitor_1_1_def_use_analyze_visitor.html#a9c55e7d17ed48d0d64b8acb1dd4cc060">nmodl::visitor::DefUseAnalyzeVisitor::visit_verbatim</a>  (const <a class="el" href="classnmodl_1_1ast_1_1_verbatim.html" title="Represents a C code block.">ast::Verbatim</a> &amp;node) override</dt>
<dd><a class="anchor" id="_todo000066"></a>One simple way would be to look for p_name in the string of verbatim block to find the variable usage.  </dd>
<dt>Class <a class="el" href="classnmodl_1_1visitor_1_1_inline_visitor.html">nmodl::visitor::InlineVisitor</a>  </dt>
<dd><a class="anchor" id="_todo000068"></a><ul>
<li>Recursive function calls are not supported and need to add checks to avoid stack explosion</li>
<li>Currently we rename variables more than necessary, this could be improved [low priority]</li>
<li>Function calls as part of an argument of function call itself are not completely inlined [low priority]</li>
<li><a class="el" href="struct_symbol.html">Symbol</a> table pass needs to be re-run in order to update the definitions/usage</li>
<li>Location of symbol/nodes after inlining still points to old nodes  </li>
</ul>
</dd>
<dt>Member <a class="el" href="classnmodl_1_1visitor_1_1_inline_visitor.html#aec884c3dd17991a7fb6a4ae7e2d19eb4">nmodl::visitor::InlineVisitor::can_replace_statement</a>  (const std::shared_ptr&lt; ast::Statement &gt; &amp;statement)</dt>
<dd><a class="anchor" id="_todo000067"></a>Add method to ast itself to simplify this implementation  </dd>
<dt>Class <a class="el" href="classnmodl_1_1visitor_1_1_localize_visitor.html">nmodl::visitor::LocalizeVisitor</a>  </dt>
<dd><a class="anchor" id="_todo000073"></a><ul>
<li>We are excluding procedures/functions because they will be still using global variables. We need to have dead-code removal pass to eliminate unused procedures/ functions before localizer pass.  </li>
</ul>
</dd>
<dt>Member <a class="el" href="classnmodl_1_1visitor_1_1_localize_visitor.html#ad865a0eb75ee7212520bfc092162f188">nmodl::visitor::LocalizeVisitor::variables_to_optimize</a>  () const</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000071"></a>Voltage v can be global variable as well as external. In order to avoid optimizations, we need to handle this case properly </p>
<p class="enddd"><a class="anchor" id="_todo000072"></a>Instead of ast node, use symbol properties to check variable type  </p>
</dd>
<dt>Class <a class="el" href="classnmodl_1_1visitor_1_1_local_to_assigned_visitor.html">nmodl::visitor::LocalToAssignedVisitor</a>  </dt>
<dd><a class="anchor" id="_todo000069"></a><ul>
<li>Variables like qt are often constant. As long as INITIAL block is executed serially or qt is updated in atomic way then we don't have a problem.  </li>
</ul>
</dd>
<dt>Class <a class="el" href="classnmodl_1_1visitor_1_1_local_var_rename_visitor.html">nmodl::visitor::LocalVarRenameVisitor</a>  </dt>
<dd><a class="anchor" id="_todo000070"></a><ul>
<li>Currently we are renaming variables even if there is no inlining candidates. In this case ideally we should not rename.  </li>
</ul>
</dd>
<dt>Class <a class="el" href="classnmodl_1_1visitor_1_1_perf_visitor.html">nmodl::visitor::PerfVisitor</a>  </dt>
<dd><a class="anchor" id="_todo000074"></a><ul>
<li>To measure the performance of statements like if, elseif and else, we have to find maximum performance from if,elseif,else and then use it to calculate total performance. In the current implementation we are doing sum of all blocks. We need to override IfStatement (which has all sub-blocks) and get maximum performance of all statements recursively. </li>
</ul>
</dd>
<dt>Class <a class="el" href="classnmodl_1_1visitor_1_1_rename_visitor.html">nmodl::visitor::RenameVisitor</a>  </dt>
<dd><a class="anchor" id="_todo000075"></a>Add log/warning messages.  </dd>
<dt>Member <a class="el" href="classnmodl_1_1visitor_1_1_symtab_visitor.html#acecb22d0c928ea76b67abef5e83b989d">nmodl::visitor::SymtabVisitor::visit_table_statement</a>  (<a class="el" href="classnmodl_1_1ast_1_1_table_statement.html" title="Represents TABLE statement in NMODL.">ast::TableStatement</a> &amp;node) override</dt>
<dd><a class="anchor" id="_todo000076"></a>we assume table statement follows variable declaration  </dd>
<dt>Class <a class="el" href="classnmodl_1_1visitor_1_1_var_usage_visitor.html">nmodl::visitor::VarUsageVisitor</a>  </dt>
<dd><a class="anchor" id="_todo000077"></a>Check if macro is considered as variable  </dd>
<dt>Class <a class="el" href="classnmodl_1_1visitor_1_1_verbatim_var_rename_visitor.html">nmodl::visitor::VerbatimVarRenameVisitor</a>  </dt>
<dd><a class="anchor" id="_todo000078"></a>Check if symbol table lookup is ok or there are cases where this could be error prone.  </dd>
<dt>Member <a class="el" href="struct_prop.html#ac0901f1cf456e93befc9b1a0cf3b5d4c">Prop::translate_legacy_index</a>  (int legacy_index) const</dt>
<dd><a class="anchor" id="_todo000081"></a>Reimplement this using the new helpers.  </dd>
<dt>Member <a class="el" href="netcvode_8hpp.html#a28a892538cd507300cceb5b2d5159899">QTYPE</a>  </dt>
<dd><a class="anchor" id="_todo000003"></a>: check if stl queue works with move_event functions.  </dd>
<dt>Member <a class="el" href="test_2nmodl_2transpiler_2unit_2symtab_2symbol__table_8cpp.html#a780700b9cd74cc6da7faa0250d3e64d5">SCENARIO</a>  ("Global symbol table (ModelSymbol) allows scope based operations")</dt>
<dd><a class="anchor" id="_todo000084"></a>: not sure how to capture std::cout </dd>
</dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<div id="nav-path" class="navpath">
  <ul>
  </ul>
</div>
<hr class="footer"/>
<address class="footer">
    <small>
    </small>
</address>
<!--END !GENERATE_TREEVIEW-->
</body>
</html>
